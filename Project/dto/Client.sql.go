// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: Client.sql

package dto

import (
	"context"
	"database/sql"
)

const createClient = `-- name: CreateClient :execresult
INSERT INTO Cliente (nombre, telefono)
VALUES (?,?)
`

type CreateClientParams struct {
	Nombre   string `json:"nombre"`
	Telefono string `json:"telefono"`
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createClient, arg.Nombre, arg.Telefono)
}

const deleteClient = `-- name: DeleteClient :execresult
DELETE FROM Cliente WHERE idCliente = ?
`

func (q *Queries) DeleteClient(ctx context.Context, idcliente int32) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteClient, idcliente)
}

const deleteClientByName = `-- name: DeleteClientByName :execresult
DELETE FROM Cliente WHERE nombre = ?
`

func (q *Queries) DeleteClientByName(ctx context.Context, nombre string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteClientByName, nombre)
}

const getAllClients = `-- name: GetAllClients :many
SELECT idCliente, nombre, telefono FROM Cliente
`

func (q *Queries) GetAllClients(ctx context.Context) ([]Cliente, error) {
	rows, err := q.db.QueryContext(ctx, getAllClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cliente
	for rows.Next() {
		var i Cliente
		if err := rows.Scan(&i.Idcliente, &i.Nombre, &i.Telefono); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientById = `-- name: GetClientById :one
SELECT idCliente, nombre, telefono
FROM Cliente WHERE idCliente = ? LIMIT 1
`

func (q *Queries) GetClientById(ctx context.Context, idcliente int32) (Cliente, error) {
	row := q.db.QueryRowContext(ctx, getClientById, idcliente)
	var i Cliente
	err := row.Scan(&i.Idcliente, &i.Nombre, &i.Telefono)
	return i, err
}

const getClientByName = `-- name: GetClientByName :one
SELECT idCliente, nombre, telefono 
FROM Cliente WHERE nombre = ? LIMIT 1
`

func (q *Queries) GetClientByName(ctx context.Context, nombre string) (Cliente, error) {
	row := q.db.QueryRowContext(ctx, getClientByName, nombre)
	var i Cliente
	err := row.Scan(&i.Idcliente, &i.Nombre, &i.Telefono)
	return i, err
}

const updateClient = `-- name: UpdateClient :execresult
UPDATE Cliente
SET nombre = ?, telefono = ?
WHERE idCliente = ?
`

type UpdateClientParams struct {
	Nombre    string `json:"nombre"`
	Telefono  string `json:"telefono"`
	Idcliente int32  `json:"idcliente"`
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateClient, arg.Nombre, arg.Telefono, arg.Idcliente)
}
